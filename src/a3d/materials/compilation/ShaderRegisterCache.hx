package a3d.materials.compilation;


/**
 * ShaderRegister Cache provides the usage management system for all registers during shading compilation.
 */
class ShaderRegisterCache
{
	private var _fragmentTempCache:RegisterPool;
	private var _vertexTempCache:RegisterPool;
	private var _varyingCache:RegisterPool;
	private var _fragmentConstantsCache:RegisterPool;
	private var _vertexConstantsCache:RegisterPool;
	private var _textureCache:RegisterPool;
	private var _vertexAttributesCache:RegisterPool;
	private var _vertexConstantOffset:UInt;
	private var _vertexAttributesOffset:UInt;
	private var _varyingsOffset:UInt;
	private var _fragmentConstantOffset:UInt;

	private var _fragmentOutputRegister:ShaderRegisterElement;
	private var _vertexOutputRegister:ShaderRegisterElement;
	private var _numUsedVertexConstants:UInt;
	private var _numUsedFragmentConstants:UInt;
	private var _numUsedStreams:UInt;
	private var _numUsedTextures:UInt;
	private var _numUsedVaryings:UInt;
	private var _profile:String;

	/**
	 * Create a new ShaderRegisterCache object.
	 */
	public function new(profile:String)
	{
		_profile = profile;
	}

	/**
	 * Resets all registers.
	 */
	public function reset():Void
	{
		_fragmentTempCache = new RegisterPool("ft", 8, false);
		_vertexTempCache = new RegisterPool("vt", 8, false);
		_varyingCache = new RegisterPool("v", 8);
		_textureCache = new RegisterPool("fs", 8);
		_vertexAttributesCache = new RegisterPool("va", 8);
		_fragmentConstantsCache = new RegisterPool("fc", 28);
		_vertexConstantsCache = new RegisterPool("vc", 128);
		_fragmentOutputRegister = new ShaderRegisterElement("oc", -1);
		_vertexOutputRegister = new ShaderRegisterElement("op", -1);
		_numUsedVertexConstants = 0;
		_numUsedStreams = 0;
		_numUsedTextures = 0;
		_numUsedVaryings = 0;
		_numUsedFragmentConstants = 0;
		var i:Int;
		for (i = 0; i < _vertexAttributesOffset; ++i)
			getFreeVertexAttribute();
		for (i = 0; i < _vertexConstantOffset; ++i)
			getFreeVertexConstant();
		for (i = 0; i < _varyingsOffset; ++i)
			getFreeVarying();
		for (i = 0; i < _fragmentConstantOffset; ++i)
			getFreeFragmentConstant();

	}

	public function dispose():Void
	{
		_fragmentTempCache.dispose();
		_vertexTempCache.dispose();
		_varyingCache.dispose();
		_fragmentConstantsCache.dispose();
		_vertexAttributesCache.dispose();

		_fragmentTempCache = null;
		_vertexTempCache = null;
		_varyingCache = null;
		_fragmentConstantsCache = null;
		_vertexAttributesCache = null;
		_fragmentOutputRegister = null;
		_vertexOutputRegister = null;
	}

	/**
	 * Marks a fragment temporary register as used, so it cannot be retrieved.
	 * @param register The register to mark as used.
	 * @param usageCount The amount of usages to add.
	 */
	public function addFragmentTempUsages(register:ShaderRegisterElement, usageCount:UInt):Void
	{
		_fragmentTempCache.addUsage(register, usageCount);
	}

	/**
	 * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
	 * @param register The register for which to remove a usage.
	 */
	public function removeFragmentTempUsage(register:ShaderRegisterElement):Void
	{
		_fragmentTempCache.removeUsage(register);
	}

	/**
	 * Marks a vertex temporary register as used, so it cannot be retrieved.
	 * @param register The register to mark as used.
	 * @param usageCount The amount of usages to add.
	 */
	public function addVertexTempUsages(register:ShaderRegisterElement, usageCount:UInt):Void
	{
		_vertexTempCache.addUsage(register, usageCount);
	}

	/**
	 * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
	 * @param register The register for which to remove a usage.
	 */
	public function removeVertexTempUsage(register:ShaderRegisterElement):Void
	{
		_vertexTempCache.removeUsage(register);
	}

	/**
	 * Retrieve an entire fragment temporary register that's still available.
	 */
	public function getFreeFragmentVectorTemp():ShaderRegisterElement
	{
		return _fragmentTempCache.requestFreeVectorReg();
	}

	/**
	 * Retrieve a single component from a fragment temporary register that's still available.
	 */
	public function getFreeFragmentSingleTemp():ShaderRegisterElement
	{
		return _fragmentTempCache.requestFreeRegComponent();
	}

	/**
	 * Retrieve an available varying register
	 */
	public function getFreeVarying():ShaderRegisterElement
	{
		++_numUsedVaryings;
		return _varyingCache.requestFreeVectorReg();
	}

	/**
	 * Retrieve an available fragment constant register
	 */
	public function getFreeFragmentConstant():ShaderRegisterElement
	{
		++_numUsedFragmentConstants;
		return _fragmentConstantsCache.requestFreeVectorReg();
	}

	/**
	 * Retrieve an available vertex constant register
	 */
	public function getFreeVertexConstant():ShaderRegisterElement
	{
		++_numUsedVertexConstants;
		return _vertexConstantsCache.requestFreeVectorReg();
	}

	/**
	 * Retrieve an entire vertex temporary register that's still available.
	 */
	public function getFreeVertexVectorTemp():ShaderRegisterElement
	{
		return _vertexTempCache.requestFreeVectorReg();
	}

	/**
	 * Retrieve a single component from a vertex temporary register that's still available.
	 */
	public function getFreeVertexSingleTemp():ShaderRegisterElement
	{
		return _vertexTempCache.requestFreeRegComponent();
	}

	/**
	 * Retrieve an available vertex attribute register
	 */
	public function getFreeVertexAttribute():ShaderRegisterElement
	{
		++_numUsedStreams;
		return _vertexAttributesCache.requestFreeVectorReg();
	}

	/**
	 * Retrieve an available texture register
	 */
	public function getFreeTextureReg():ShaderRegisterElement
	{
		++_numUsedTextures;
		return _textureCache.requestFreeVectorReg();
	}

	/**
	 * Indicates the start index from which to retrieve vertex constants.
	 */
	private inline function get_vertexConstantOffset():UInt
	{
		return _vertexConstantOffset;
	}

	private inline function set_vertexConstantOffset(vertexConstantOffset:UInt):Void
	{
		_vertexConstantOffset = vertexConstantOffset;
	}

	/**
	 * Indicates the start index from which to retrieve vertex attributes.
	 */
	private inline function get_vertexAttributesOffset():UInt
	{
		return _vertexAttributesOffset;
	}

	private inline function set_vertexAttributesOffset(value:UInt):Void
	{
		_vertexAttributesOffset = value;
	}

	private inline function get_varyingsOffset():UInt
	{
		return _varyingsOffset;
	}

	private inline function set_varyingsOffset(value:UInt):Void
	{
		_varyingsOffset = value;
	}

	private inline function get_fragmentConstantOffset():UInt
	{
		return _fragmentConstantOffset;
	}

	private inline function set_fragmentConstantOffset(value:UInt):Void
	{
		_fragmentConstantOffset = value;
	}

	/**
	 * The fragment output register.
	 */
	private inline function get_fragmentOutputRegister():ShaderRegisterElement
	{
		return _fragmentOutputRegister;
	}

	/**
	 * The amount of used vertex constant registers.
	 */
	private inline function get_numUsedVertexConstants():UInt
	{
		return _numUsedVertexConstants;
	}

	/**
	 * The amount of used fragment constant registers.
	 */
	private inline function get_numUsedFragmentConstants():UInt
	{
		return _numUsedFragmentConstants;
	}

	/**
	 * The amount of used vertex streams.
	 */
	private inline function get_numUsedStreams():UInt
	{
		return _numUsedStreams;
	}

	private inline function get_numUsedTextures():UInt
	{
		return _numUsedTextures;
	}

	private inline function get_numUsedVaryings():UInt
	{
		return _numUsedVaryings;
	}
}
